require('dotenv').config()
const { MongoClient, ObjectId } = require('mongodb')
const fs = require('fs')
const path = require('path')

async function main() {
  const uri = process.env.MONGODB_URI
  const dbName = process.env.DB_NAME || 'shoplite'
  if (!uri) throw new Error('MONGODB_URI not set')
  const client = new MongoClient(uri)
  await client.connect()
  const db = client.db(dbName)

  console.log('Seeding database...', dbName)

  // Products from mock-catalog.json (try multiple candidate paths)
  const candidates = [
    path.join(__dirname, '../../storefront/public/mock-catalog.json'),
    path.join(process.cwd(), '..', 'storefront', 'public', 'mock-catalog.json'),
    path.join(process.cwd(), '..', '..', 'storefront', 'public', 'mock-catalog.json'),
  ]
  let mock = []
  for (const p of candidates) {
    if (fs.existsSync(p)) {
      const raw = fs.readFileSync(p, 'utf-8')
      mock = JSON.parse(raw)
      console.log('Loaded mock-catalog from', p)
      break
    }
  }
  if (!mock.length) {
    console.warn('mock-catalog.json not found; generating fallback products')
    const tags = ['electronics','audio','home','fitness','accessories','outdoors']
    mock = Array.from({ length: 24 }).map((_, i) => ({
      title: `Product ${i + 1}`,
      description: 'Autogenerated item',
      price: Math.round((Math.random() * 495 + 5) * 100) / 100,
      tags: [tags[i % tags.length]],
      image: '/logo.svg',
      stockQty: Math.floor(Math.random() * 50) + 1,
    }))
  }
  const products = mock.map((p) => ({
    name: p.title,
    description: p.description || '',
    price: p.price,
    category: (p.tags && p.tags[0]) || 'General',
    tags: p.tags || [],
    imageUrl: p.image,
    stock: typeof p.stockQty === 'number' ? p.stockQty : Math.floor(Math.random() * 50) + 1,
    createdAt: new Date(),
  }))

  await db.collection('products').deleteMany({})
  const prodRes = await db.collection('products').insertMany(products)
  const prodIds = Object.values(prodRes.insertedIds)

  // Customers
  await db.collection('customers').deleteMany({})
  const customers = Array.from({ length: 12 }).map((_, i) => ({
    name: `Demo User ${i + 1}`,
    email: i === 0 ? 'demo@example.com' : `user${i + 1}@example.com`,
    phone: `+123456789${i}`,
    address: `${10 + i} Example St, City`,
    createdAt: new Date(),
  }))
  const custRes = await db.collection('customers').insertMany(customers)
  const custIds = Object.values(custRes.insertedIds)

  // Orders
  await db.collection('orders').deleteMany({})
  const statuses = ['PENDING', 'PROCESSING', 'SHIPPED', 'DELIVERED']
  const orders = []
  for (let i = 0; i < 18; i++) {
    const c = custIds[i % custIds.length]
    const items = []
    for (let j = 0; j < 2 + (i % 3); j++) {
      const pid = prodIds[(i + j) % prodIds.length]
      const p = products[(i + j) % products.length]
      items.push({ productId: pid, name: p.name, price: p.price, quantity: 1 + (j % 2) })
    }
    const total = items.reduce((s, it) => s + it.price * it.quantity, 0)
    const status = statuses[i % statuses.length]
    const createdAt = new Date(Date.now() - (i * 86400000) / 2)
    const order = {
      customerId: c,
      items,
      total,
      status,
      carrier: 'DHL',
      estimatedDelivery: new Date(createdAt.getTime() + 6 * 86400000),
      createdAt,
      updatedAt: createdAt,
    }
    orders.push(order)
  }
  await db.collection('orders').insertMany(orders)

  console.log('Seed complete: ', {
    products: products.length,
    customers: customers.length,
    orders: orders.length,
  })
  await client.close()
}

main().catch((e) => { console.error(e); process.exit(1) })
